#!/usr/bin/env bun

/**
 * Real Integration Test - Uses actual Tambo and Groq APIs
 * 
 * This test:
 * 1. Sends real prompts to backend
 * 2. Backend uses Groq to generate workflows
 * 3. Validates the generated workflow structure
 * 4. Tests the complete flow from chat to workflow generation
 */

import { v4 as uuidv4 } from "uuid";

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || "http://localhost:3000";

interface IntentResponse {
  workflowPrompt?: string;
  components: string[];
  correlationId: string;
}

interface WorkflowResponse {
  nodes: any[];
  edges: any[];
  metadata?: any;
}

async function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function testRealWorkflowGeneration(prompt: string): Promise<boolean> {
  const correlationId = uuidv4();

  console.log(`\nüß™ Testing Real Workflow Generation`);
  console.log(`üìù Prompt: "${prompt}"`);
  console.log(`üîó Correlation ID: ${correlationId}`);

  try {
    // Step 1: Get intent from backend
    console.log(`\nüì° Step 1: Sending to /ai/intent...`);
    const intentResponse = await fetch(`${BACKEND_URL}/ai/intent`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ prompt, correlationId }),
    });

    if (!intentResponse.ok) {
      throw new Error(`Intent endpoint returned ${intentResponse.status}`);
    }

    const intent: IntentResponse = await intentResponse.json();
    console.log(`‚úÖ Intent received:`, {
      components: intent.components,
      hasWorkflowPrompt: !!intent.workflowPrompt,
    });

    // Step 2: Generate workflow using Groq
    if (intent.workflowPrompt) {
      console.log(`\nü§ñ Step 2: Generating workflow with Groq...`);
      console.log(`   Using prompt: "${intent.workflowPrompt}"`);

      const workflowResponse = await fetch(`${BACKEND_URL}/workflow/generate`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ prompt: intent.workflowPrompt }),
      });

      if (!workflowResponse.ok) {
        throw new Error(`Workflow generation returned ${workflowResponse.status}`);
      }

      const workflow: WorkflowResponse = await workflowResponse.json();

      console.log(`‚úÖ Workflow generated by Groq:`);
      console.log(`   Nodes: ${workflow.nodes?.length || 0}`);
      console.log(`   Edges: ${workflow.edges?.length || 0}`);

      // Validate workflow structure
      if (!workflow.nodes || !Array.isArray(workflow.nodes)) {
        throw new Error("Invalid workflow: missing nodes array");
      }

      if (!workflow.edges || !Array.isArray(workflow.edges)) {
        throw new Error("Invalid workflow: missing edges array");
      }

      if (workflow.nodes.length === 0) {
        throw new Error("Workflow has no nodes");
      }

      // Display node details
      console.log(`\nüìä Generated Nodes:`);
      workflow.nodes.forEach((node, idx) => {
        console.log(`   ${idx + 1}. ${node.type} - ${node.data?.label || "Unlabeled"}`);
      });

      // Display edge connections
      if (workflow.edges.length > 0) {
        console.log(`\nüîó Generated Edges:`);
        workflow.edges.forEach((edge, idx) => {
          const sourceNode = workflow.nodes.find((n) => n.id === edge.source);
          const targetNode = workflow.nodes.find((n) => n.id === edge.target);
          console.log(
            `   ${idx + 1}. ${sourceNode?.type || edge.source} ‚Üí ${targetNode?.type || edge.target}`
          );
        });
      }

      // Validate node types
      const validNodeTypes = [
        "input",
        "inputValidation",
        "dbFind",
        "dbInsert",
        "dbUpdate",
        "dbDelete",
        "emailSend",
        "userLogin",
        "authMiddleware",
        "response",
      ];

      const invalidNodes = workflow.nodes.filter(
        (node) => !validNodeTypes.includes(node.type)
      );

      if (invalidNodes.length > 0) {
        console.warn(`‚ö†Ô∏è  Warning: Found ${invalidNodes.length} nodes with unknown types`);
        invalidNodes.forEach((node) => {
          console.warn(`   - ${node.type}`);
        });
      }

      console.log(`\n‚úÖ Workflow structure is valid`);
      return true;
    } else {
      console.log(`‚ÑπÔ∏è  No workflow generation needed for this intent`);
      return true;
    }
  } catch (error) {
    console.error(`‚ùå Test failed:`, error instanceof Error ? error.message : error);
    return false;
  }
}

async function testMultiplePrompts(): Promise<void> {
  const testCases = [
    {
      name: "Simple Signup API",
      prompt: "create a signup api with email and password validation",
      expectedNodes: ["input", "inputValidation", "dbInsert"],
    },
    {
      name: "Login API",
      prompt: "create a login api that checks email and password",
      expectedNodes: ["input", "dbFind"],
    },
    {
      name: "User Profile Update",
      prompt: "create an api to update user profile with authentication",
      expectedNodes: ["input", "authMiddleware", "dbUpdate"],
    },
    {
      name: "Email Notification",
      prompt: "create an api that sends welcome email after user registration",
      expectedNodes: ["input", "dbInsert", "emailSend"],
    },
  ];

  console.log(`\n${"=".repeat(70)}`);
  console.log(`üöÄ REAL INTEGRATION TEST - TAMBO + GROQ`);
  console.log(`${"=".repeat(70)}`);

  let passed = 0;
  let failed = 0;
  const startTime = Date.now();

  for (const testCase of testCases) {
    console.log(`\n${"‚îÄ".repeat(70)}`);
    console.log(`üìã Test Case: ${testCase.name}`);
    console.log(`${"‚îÄ".repeat(70)}`);

    const result = await testRealWorkflowGeneration(testCase.prompt);

    if (result) {
      passed++;
      console.log(`\n‚úÖ ${testCase.name} - PASSED`);
    } else {
      failed++;
      console.log(`\n‚ùå ${testCase.name} - FAILED`);
    }

    // Wait between tests to avoid rate limiting
    if (testCase !== testCases[testCases.length - 1]) {
      console.log(`\n‚è≥ Waiting 2 seconds before next test...`);
      await sleep(2000);
    }
  }

  const duration = Date.now() - startTime;

  console.log(`\n${"=".repeat(70)}`);
  if (failed === 0) {
    console.log(`‚úÖ ALL REAL INTEGRATION TESTS PASSED`);
  } else {
    console.log(`‚ùå SOME TESTS FAILED`);
  }
  console.log(`${"=".repeat(70)}`);
  console.log(`‚úÖ Passed: ${passed}/${testCases.length} tests`);
  console.log(`‚ùå Failed: ${failed}/${testCases.length} tests`);
  console.log(`‚è±Ô∏è  Total Duration: ${(duration / 1000).toFixed(1)}s`);
  console.log(`${"=".repeat(70)}`);

  if (failed === 0) {
    console.log(`\nüéâ REAL INTEGRATION VERIFIED`);
    console.log(`\n‚ú® Successfully tested:`);
    console.log(`   ‚Ä¢ Real Tambo integration`);
    console.log(`   ‚Ä¢ Real Groq workflow generation`);
    console.log(`   ‚Ä¢ Intent detection ‚Üí Workflow generation flow`);
    console.log(`   ‚Ä¢ Multiple workflow types`);
    console.log(`   ‚Ä¢ Node and edge validation`);
    console.log(`\nüöÄ System is production-ready with real AI!`);
    console.log(`${"=".repeat(70)}\n`);
    process.exit(0);
  } else {
    console.log(`\n‚ùå Fix the failing tests.`);
    console.log(`\nüí° Check:`);
    console.log(`   ‚Ä¢ GROQ_API_KEY is set in backend/.env`);
    console.log(`   ‚Ä¢ MongoDB is running`);
    console.log(`   ‚Ä¢ Backend is running (bun run dev)`);
    console.log(`${"=".repeat(70)}\n`);
    process.exit(1);
  }
}

async function checkPrerequisites(): Promise<boolean> {
  console.log(`\nüîç Checking prerequisites...`);

  // Check backend
  try {
    const response = await fetch(`${BACKEND_URL}/hello`);
    if (!response.ok) {
      console.error(`‚ùå Backend returned ${response.status}`);
      return false;
    }
    console.log(`‚úÖ Backend is running`);
  } catch (error) {
    console.error(`‚ùå Backend is not reachable at ${BACKEND_URL}`);
    console.error(`   Start it with: cd backend && bun run dev`);
    return false;
  }

  // Check intent endpoint
  try {
    const response = await fetch(`${BACKEND_URL}/ai/intent`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ prompt: "test", correlationId: "prereq-check" }),
    });
    if (!response.ok) {
      console.error(`‚ùå Intent endpoint returned ${response.status}`);
      return false;
    }
    console.log(`‚úÖ Intent endpoint is working`);
  } catch (error) {
    console.error(`‚ùå Intent endpoint is not reachable`);
    return false;
  }

  // Check workflow generation endpoint
  try {
    const response = await fetch(`${BACKEND_URL}/workflow/generate`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ prompt: "test" }),
    });
    if (!response.ok) {
      console.error(`‚ùå Workflow generation endpoint returned ${response.status}`);
      console.error(`   Make sure GROQ_API_KEY is set in backend/.env`);
      return false;
    }
    console.log(`‚úÖ Workflow generation endpoint is working`);
    console.log(`‚úÖ Groq API is accessible`);
  } catch (error) {
    console.error(`‚ùå Workflow generation endpoint failed`);
    console.error(`   Error:`, error instanceof Error ? error.message : error);
    return false;
  }

  return true;
}

// Main execution
(async () => {
  if (!(await checkPrerequisites())) {
    console.error(`\n‚ùå Prerequisites check failed. Fix the issues above.\n`);
    process.exit(1);
  }

  console.log(`\n‚úÖ All prerequisites met. Starting real integration tests...\n`);
  await testMultiplePrompts();
})();
